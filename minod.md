# minod

## Brainstorming

2020-06-03

- structure hint 라는 개념을 도입하면 어떨까?
    - 메모리 크기를 최적으로 만들기 위함!
    - 만약 길이를 넘어가면?
        - 저장을 거부? ← 이건 좀...
        - 미리 확보해 둔 영역에 저장하는 대신 그때그때 메모리를 할당 (malloc) 해서? ← 이렇게 하려면 미리 mmap pool을 가지고 시작하는 편이 좋을것같다 왜냐하면 주소공간을 가능한 한 연속적으로 확보하고 싶으니까. 페이지 여러 개를 거의 동시에 할당하면 근처에 주르륵 생기지 않을까?!
- 외부 인터페이스는?
    - 네트워크
        - 네트워킹 전담 스레드 (싱글) 를 만들자
        - event loop를 구현해서
            - epoll
            - kqueue
        - 메모리 삽입/삭제 콜을 받으면 나머지 스레드의 작업 큐에 해당 내용을 넣자
        - 삽입 시에 락이 필요할까? ← 삽입 스레드가 여러 개 있을 수 있을까?
            - 페이지 단위로 락을 걸면?
        - 리얼타임 시그널? ← 좀 알아볼 필요 있음
    - 파이프는 어떨까?!
        - 같은 머신에 있다면 훌륭한 대안이 되어 줄 듯
- 처리 구조
    - 스레드 여러개
        - 네트워킹 스레드는 한 개 (이벤트 멀티플렉싱 설비에 내부적으로 락 거는 부분이 포함되어서 스레드 여러 개로 받아도 별 효과가 없지 않을까? 어짜피 직렬화될텐데!)
        - 대신 요청 스펙을 최대한 간소화해서 거의 오버헤드 (파싱 같은) 없이 작업 큐에 넣을 수 있게 하면?
            - 작업 스레드가 메인 스레드 큐에서 요청을 가져가는 방식이 좋을까
            - 메인 스레드가 적절한 작업 스레드 큐를 선택해서 (스케줄링) 요청을 밀어넣는 방식이 좋을까
    - 스레드 여러개지만 모두 리액터라면 어떨까?
    - 아니면 네트워킹 스레드만 리액터로 하고 나머지 스레드는 ForkJoinPool 같은 구조로 만들면?
        - 핵심은 work stealing 인듯
        - 하지만 이럴 경우 dining philosoper problem 같은 것이 생길 수 있지 않을까?
- 해시테이블
    - open addressing이 좋을까, separate chaining이 좋을까
    - 사용 패턴에 따라 다르다
        - 만약 일시적인 지역성을 최대한으로 확보할 수 있는 사용 패턴이라면
            - open addressing의 잇점을 챙길 수 있을 것이고
        - pointer deref 오버헤드를 어느 정도 감내할 만 하다면
            - separate chaining도 나쁘지 않을 것 같다
        - 다만 separate chaining에서 key 분포가 고르지 못해서 버킷 하나에 많은 entry가 포함된다면
            - Java의 사례처럼 5개의 원소까지는 linked list로, 5개 이상은 RB tree로 하는 방법
            - 아니면 키 분포가 충분히 쓸만하다고 가정하고 무조건 linked list로만 하는 방법
        - 마찬가지로 open addressing에서 키 분포가 고르지 못할 경우 다음 버킷을 선택하는 알고리즘은?
            - 단순히 선형식에 따라가느냐
            - 비트 단위로 연산한 다음에 모듈러를 취하느냐 (python)
            - 다른 좋은 수식을 search해서 찾거나
    - 그리고 lock은 필수이다 만약 스레드 여러개를 만들거라면
        - read lock과 write lock은 좀 구별할 필요가 있을듯
        - 항목 주변에만 락을 거느냐, 페이지 전체에 락을 거느냐의 차이 아닐까?
- 워커 프로세스를 만들고 SMP 시스템에서도 성능이 좋도록 만들고 싶다.
    - 프로세스 친화도 같은 설정도 만져보고 싶다.

## 재미있을만한 포인트들

1. 스레드 풀
2. 네트워킹 스레드 구현 (epoll, kqueue)
3. 작업 큐 구현 ← 작업 우선순위 개념을 도입할 수 있을까? ← 굳이?
4. 아키텍처 경계(를 C로 구현하는 일) ← 내가 할 수 있을까?
5. 해시 테이블 구현 (with lock?)
6. 크로스 플랫폼 ;;;
7. 에러 처리, 로깅 (요거 중요) 걍 printf 찍을까 ㅋㅋ
8. 클러스터, 파티션, ...? 여러 노드 (모든 노드가 RW가 될때) 분산된 환경에서 돌아갈 수 있을까
9. failover
10. persistent (주기적으로? background에서 event sourcing?)

# 마일스톤

뭐부터만들까?

일단 최대한 작게 iteration을 가지고 가야 하는데...

그렇다면 최대한 빨리 "동작할 수 있는 상태" 가 되어야 마땅하다

처음에는 아키텍처 내다버리자 내 역량밖인듯.

## #1 iteration

1. epoll이고 kqueue고 select고 이런거 다버린다음에 synchronous 플로우로
2. 스레드풀도 나중에
3. 네트워킹은 최소한으로만
4. 해시테이블도 최소한으로만 구현 (요거는 예전꺼 찾아서 쓰면될듯?!)
5. 빌드는 간단한 Makefile

# 구현하다가 드는 의문

- 굳이 스레드가 필요한가? 어짜피 메모리 IO는 꽤 빠르잖아
    - 만약 메모리 카피조차 일어나지 않는다면 (헤더만 읽고?!) 해볼만한듯?
    - 헤더만 읽은 소켓을 잡 큐에 던져버리고 나머지 작업은 스레드가 알아서?
        - 연달아서 해당 소켓에서 요청이 들어올 경우.. 정확하게 원하는 바이트만큼 읽어내지 않으면 하나씩 밀려서 문제가 될 수도 있겠다

## 중간점검 Jun 28, 2020

확실히 작게 여러번 하니깐 좋다.

## #2 iteration

1. 코드 정리하기 (헤더 분리도 하고)
2. 결과값도 구조체로 내려보내자

## #3 iteration

버퍼를 0으로 비우면서 버퍼를 cmd취급했더니 CMD가 0이면 GET이라서 이상하게 실행된다.

1. ~~select를 거칠까... kqueue를 써볼까... kqueue 안써봤으니까.~~
2. 클라이언트 개선
3. 프로토콜 수정

완료.

## #4 iteration

1. Map 코드 네이밍컨벤션 맞추기
2. ~~작업큐 구현? →~~ 직접 구현 말고 이미 구현된 lock-free 큐를 사용하자 → 락프리일 필요가 있을까? 아니면 차라리 싱글스레드가 나을까...

4번 이터레이션을 진행하면서 드는 생각

- process 수준의 클러스터링을 하면 어떨까?
    - 별로일듯. 왜냐하면 결국 같은 메모리 공간을 공유하거나, 아예 다른 메모리 공간을 사용해야 할텐데
        1. 같은 메모리 공간을 공유하면 락걸고 락풀다가 시간이 다 갈 거 같고
        2. 더군다나 accept 를 여러 프로세스에서 하면 어떻게 행동하는지 잘 모르는데
        3. 그렇게 할 경우에 앞에 master process를 붙이고 로드밸런싱을 하는 것처럼 가게 되나?
        4. 결국 오버헤드만 더 커지고 얻는 실익은 부족할 것이다.
        5. 게다가 이러면 NUMA도 고려할 필요가 생긴다 ㅋㅋ
            1. 이거는 나중에 main process에서 worker를 spawn하는 식으로 만드는게 현실적인 방안인듯
            2. CQRS마냥 main에는 쓰기, worker에는 읽기를 하게끔 드라이버를 만들고

스레드풀은 어떤식으로 만드는게 좋을까.

메모리 할당은 어떤식으로 하는게 좋을까.

다시 생각해보니까.. 스레드풀이 꼭 필요할까????..

1. 메인스레드 (네트워킹 및 작업분배)
2. map 스레드
3. 영속성 스레드
4. 클러스터링 스레드

요렇게하면 좋지않을까? 스레드풀 대신 각각에 task 큐를 붙이는 식으로다가..

아님 스레드에 역할을 붙이지말고 task에 할일을 넣어서 스레드풀에 떠넘길까?

근데 이러면 map 스레드가 2개 이상일때 map에 락을 걸어야 하나? 아님 샤딩처럼?

→ 샤딩 좋네~ 근데 스레드 갯수 변하면 재분배는? api 버전업 하듯이? 아 이거 마이크로서비스 뭐시기 책에서 봤던거랑 같은맥락인데 그걸 모라고 하드라... 암튼 변하기전/변한다음 둘다 잠시 유지해놓고 CUD는 둘다반영, R은 변하기전꺼에서 하다가 다 옮기면 잽싸게 락걸고 변하기전꺼 삭 날려버리기?

갑자기 드는 생각인데 아키텍처가 프랙탈 성질이 있는건 여기서 한 번 더 확인이 되는 것 같다.... 이게 망치를 들고 있어서 모든게 못으로 보이기 때문은 아닌듯.

이쯤에서 한번 아키텍처를 생각해야 할 것 같다.

1. 메인스레드
    - 네트워킹과 map 스레드 로드밸런싱 (가장 남은 task수가 작은 map task queue로 넘기자)
    - map에 task를 넘기는 동시에 영속성 스레드 큐에도 해당 task를 넘김
    - 그와 동시에 클러스터링 스레드 큐에도 해당 task를 넘김
2. map 스레드
    - 각자 map을 가지고 있으면서 map과 관련된 task를 처리하는 스레드
3. 영속성 스레드
    - task 요청을 쌓다가 적절한 주기마다 한 번 씩 디스크로 flush
4. 클러스터링 스레드
    - 단순한 map 오퍼레이션은 알려진 노드 전체에 해당 task를 브로드캐스트
        - 근데 이러면 timestamp가 필요할듯?!
    - 만약 설정이 바뀌었다면 RAFT를 적용해볼만한듯
        - 그전에 공부부터하고 ㅋㅋ

## #5 iteration

- 작업큐 구현은 미루고
- 일단 싱글스레드 기반으로 만들어보자
- kqueue ㄱ?

---

## Already implemented

1. Basic hashmap
2. Basic networking

## Will implement

---

여기서 한 한두달 안건드린듯 

대충 클라랑 서버 구현되고 0.1.0 릴리즈

되는거: get, set

뭐야 다 되네 ㅋㅋ 최고!

# 여기까지 0.1.0

이제 개선을 해야하는데

커맨드 하나 날리려고 TCP 커넥션 하나를 만들고 끊는건 아니지.. 이게 http도 아니고

그러니깐 커넥션을 추상화하자.

근데 그 전에 네트워킹 부분이랑 로직이 뒤범벅인것좀 풀어놓고

겸사겸사 epoll,kqueue도 적용을 하고 가자. (그거랑은 별개로 아직 싱글 스레드)

순서:

1. epoll, kqueue 암튼 이런 친구들 써서 네트워킹쪽을 좀 다듬고
    - 자연스럽게 컨텍스트 객체가 필요하겠네
2. 커넥션을 추상화하자!

그리고 지금시점에선 태스크를 만드는게 아니라

커맨드 받으면 그 자리에서 바로 처리하는걸로 ㅇㅇ

그리고 클라이언트도 개선해야 하는데

1. 커넥션 추상화가 끝나면
2. REPL 형태로 바꿔서 최초 시작때 다이얼을 거는 방식으로
